#!/usr/bin/env bash
# treecat.sh
# Create a snapshot of a directory structure and its file contents. Combines a
# 'tree' view with the concatenated content of files, excluding common bloat.

set -euo pipefail

usage() {
  cat <<'EOF'
Usage: treecat.sh [OPTIONS] [--] [DIR1 [DIR2 ...]]

Description:
  Creates a comprehensive text snapshot of a project. It combines a
  directory tree view with the content of the files, making it easy to
  share, document, or feed into AI models.

Options:
  -t, --tree              Print directory tree before file contents.
  -y, --only-tree         Only print the tree (no file contents), respecting bloat exclusions.
  -T, --no-tree           Skip the tree view (default).
  -b, --bloat             Exclude common bloat (e.g., node_modules, .git, build, dist,
                          .venv, target, .DS_Store, .env*). This is the recommended default.
  -i, --include PATTERN   Include only files matching shell PATTERN (can be repeated).
  -x, --exclude PATTERN   Exclude files matching shell PATTERN (can be repeated).
  -n, --no-header         Omit BEGIN/END markers around each file's content.
  -o, --output FILE       Write snapshot to FILE instead of stdout.
  -h, --help              Show this help and exit.

Examples:
  # Create a full snapshot with a tree, excluding bloat, and save to a file
  treecat.sh -t -b -o my-project.txt

  # Only show the directory structure of the 'src' folder
  treecat.sh -y -b src/

  # Snapshot only JavaScript and Markdown files from multiple directories
  treecat.sh -t -b -i '*.js' -i '*.md' src/ docs/
EOF
}

########################################
# Defaults
show_tree=false
only_tree=false
headers=true
exclude_bloat=false
declare -a includes=()
declare -a excludes=()
output=""
declare -a search_dirs=()

########################################
# Parse options
while [[ $# -gt 0 ]]; do
  case "$1" in
    -t|--tree)        show_tree=true;      shift ;;
    -y|--only-tree)   only_tree=true;      shift ;;
    -T|--no-tree)     show_tree=false;     shift ;;
    -b|--bloat)       exclude_bloat=true;  shift ;;
    -i|--include)     includes+=("$2");   shift 2 ;;
    -x|--exclude)     excludes+=("$2");   shift 2 ;;
    -n|--no-header)   headers=false;       shift ;;
    -o|--output)      output="$2";        shift 2 ;;
    -h|--help)        usage; exit 0 ;;
    --)               shift; search_dirs+=("$@"); break ;;
    -*)               echo "Unknown option: $1" >&2; usage; exit 1 ;;
    *)                search_dirs+=("$1"); shift ;;
  esac
done
[[ ${#search_dirs[@]} -eq 0 ]] && search_dirs=(".")

# Redirect output early
[[ -n "$output" ]] && exec >"$output"

########################################
# Define bloat patterns
declare -a bloat_patterns=()
if [[ "$exclude_bloat" == true ]]; then
  bloat_patterns=(
    # General
    '.git' '.DS_Store' 'logs' 'tmp'

    # IDEs & Editors
    '.idea' '.vscode' '*.sublime-project' '*.sublime-workspace'

    # Build & Cache Outputs
    'build' 'dist' 'out' 'coverage' '.next' '__pycache__'

    # Dependencies
    'node_modules' 'vendor'

    # Language & Framework Specific
    'target'        # Rust, Maven
    '.venv'         # Python virtualenvs
    'env'           # Python virtualenvs
    '.pytest_cache'
    '.mypy_cache'
    '.gradle'       # Gradle
    'bin'           # .NET, C/C++
    'obj'           # .NET, C/C++
    '*.tfstate*'    # Terraform state
    '.terraform'    # Terraform plugins

    # Sensitive Files
    '.env*' '*.env'
  )
fi

########################################
# (1) Directory tree
if [[ "$show_tree" == true || "$only_tree" == true ]]; then
  if command -v tree >/dev/null 2>&1; then
    tree_opts=(-a)
    if [[ ${#bloat_patterns[@]} -gt 0 ]]; then
      # Join array with | for the tree ignore pattern
      ignore_pattern=$(printf "|%s" "${bloat_patterns[@]}")
      ignore_pattern=${ignore_pattern:1}
      tree_opts+=(-I "$ignore_pattern")
    fi

    echo "### Directory structure (generated by treecat on $(date +%Y-%m-%d\ %H:%M:%S))"
    tree "${tree_opts[@]}" "${search_dirs[@]}"
    echo
  else
    echo "WARNING: 'tree' command not found; skipping directory tree view." >&2
    echo "         On macOS: brew install tree" >&2
    echo "         On Debian/Ubuntu: sudo apt-get install tree" >&2
  fi
  # If only tree requested, exit here
  if [[ "$only_tree" == true ]]; then
    exit 0
  fi
fi

########################################
# (2) Build raw file list with find + optional prune
find_args=("${search_dirs[@]}")
if [[ ${#bloat_patterns[@]} -gt 0 ]]; then
  prune_args=()
  for pat in "${bloat_patterns[@]}"; do
    prune_args+=(-name "$pat" -o)
  done
  unset 'prune_args[${#prune_args[@]}-1]' # remove last -o
  find_args+=(\( "${prune_args[@]}" \) -prune -o)
fi
find_args+=(-type f -print)

# Use a while-read loop for compatibility with older Bash versions (like on macOS)
declare -a raw_files=()
while IFS= read -r file; do
    raw_files+=("$file")
done < <(find "${find_args[@]}" | sort)


########################################
# (3) Apply include/exclude patterns
declare -a files=()
for f in "${raw_files[@]}"; do
  # Normalize path for matching
  p=${f#./}

  # --- FIX STARTS HERE ---
  # Process excludes first only if the excludes array has elements
  skip=false
  if ((${#excludes[@]})); then
    for pat in "${excludes[@]}"; do
      if [[ $p == $pat ]]; then
        skip=true
        break
      fi
    done
  fi
  $skip && continue
  # --- FIX ENDS HERE ---

  # Process includes if any are specified
  if ((${#includes[@]})); then
    keep=false
    for pat in "${includes[@]}"; do
      if [[ $p == $pat ]]; then
        keep=true
        break
      fi
    done
    $keep || continue
  fi
  files+=("$f")
done

########################################
# (4) Output file contents
for f in "${files[@]}"; do
  # Skip empty files
  [[ -s "$f" ]] || continue

  # Check if file is text-based before printing
  if [[ "$(file -b --mime-type "$f")" == text/* || "$(file -b --mime-type "$f")" == application/json ]]; then
    if [[ "$headers" == true ]]; then
      printf '\n===== BEGIN %s =====\n' "$f"
    fi
    cat "$f"
    if [[ "$headers" == true ]]; then
      printf '\n===== END %s =====\n' "$f"
    fi
  fi
done